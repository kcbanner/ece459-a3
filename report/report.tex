\documentclass[12pt]{article}

\usepackage[letterpaper, hmargin=0.75in, vmargin=0.75in]{geometry}
\usepackage{float}
\usepackage{listings}

\pagestyle{empty}

\title{ECE 459: Programming for Performance\\Assignment 3}
\author{Casey Banner and Stephan van den Heuvel}
\date{March 25, 2013}

\lstset{
  frame=single,
  basicstyle=\ttfamily\footnotesize,
  framesep=10pt,
  aboveskip=10pt,
  belowskip=10pt
}


\begin{document}

\maketitle

\section*{Baseline Performance}

% - Talk about 25s avg execution time
% - Talk about Google Profiler, and how it is instrumented

The execution time of the provided assignment code over an average of
5 runs was $26.031$s. In order to understand where time was being spent
within the model the gperftools CPU profiler was used. For profiling
purposes, the test harness was instrumented as follows:

\begin{lstlisting}[language=C]
ProfilerStart("morph.profile");
m.morph(0, 0.5, 1.25, 0.2);
m.morph(1, 0.5, 1.25, 0.2);
ProfilerStop();
\end{lstlisting}

The resultant profile was then analyzed with the \texttt{pprof}
utility in order to get a line-by-line breakdown of how the execution
time was distributed. An excerpt of the output follows:

\begin{lstlisting}
     1      1  110:  double ww[lines];
    29     29  111:  QPoint pp[lines];
     .      .  112:
     .      .  113:  // for each line
     8      8  114:  for(int k=0; k<lines; ++k) {
     .      .  115:
     .      .  116:      // get original lines from reference line
    47     47  117:      QPoint P = listLines[h]->at(k).first;
     .      .  118:      QPoint Q = listLines[h]->at(k).second;
     .      .  119:
    35     35  120:      QVector2D XP(X - P);
    37     37  121:      QVector2D QP(Q - P);
     .      .  122:
    40     40  123:      QVector2D pQP(QP.y(), -QP.x());
     .      .  124:
     .      .  125:      // Calculate u, v
   414    414  126:      u = QVector2D::dotProduct(XP, QP) /  QP.lengthSquared();
     .      .  127:      v = QVector2D::dotProduct(XP, pQP) / QP.length();
     .      .  128:
     .      .  129:      // get interpolating lines from reference line
     7      7  130:      QPoint P2 = listAux[h]->at(k).first;
     .      .  131:      QPoint Q2 = listAux[h]->at(k).second;
     .      .  132:
    23     23  133:      QVector2D Q2P2(Q2 - P2);
    24     24  134:      QVector2D pQ2P2(Q2P2.y(), -Q2P2.x());
     .      .  135:
   438    438  136:      QVector2D X2 = QVector2D(P2) + u*Q2P2 + (v*pQ2P2)
                                        / Q2P2.length();
     .      .  137:
   126    126  138:      QPoint p = X2.toPoint() - X;
     .      .  139:

                         ...

     .      .  145:      double w = 0;
     1      1  146:      w =  pow(QP.length(), VARP);
     8      8  147:      w /= (VARA + dist);
    21     21  148:      w = pow(w, VARB);
     .      .  149:
     8      8  150:      ww[k] = w;
    11     11  151:      pp[k] = p;
     .      .  152:  }
     .      .  153:
     .      .  154:  QPoint sum(0.0, 0.0);
     .      .  155:  double wsum = 0;
    45     45  156:  for(int k=0; k<lines; ++k) {
   261    261  157:      sum  += ww[k] * pp[k];
     .      .  158:      wsum += ww[k];
     .      .  159:  }
   108    108  160:  sum /= wsum;
\end{lstlisting}

From this analysis we can see that the areas where the most time is spent are:

% - length() is slow
% - big calculations are slow (u, v)
% - the final summation loop is slow

\begin{itemize}
  \item The \texttt{u} and \texttt{v} calcuations
  \item The \texttt{X2} calculation
  \item The weighted sum calcuation
  \item The calculation of \texttt{w} and \texttt{p}
\end{itemize}

The \texttt{w} calculation involves expensive calls to \texttt{pow}
with fractional exponents, and we can see the effects of this in the
\texttt{pprof --text} output:

\begin{lstlisting}
  2365  37.0%  37.0%     2365  37.0% __log10_finite
  1784  27.9%  64.8%     1784  27.9% Model::morph
  1381  21.6%  86.4%     1381  21.6% __exp_finite
   230   3.6%  90.0%      230   3.6% 00007f19fa8f8b7f
   120   1.9%  91.9%      120   1.9% pow
    61   1.0%  92.9%       61   1.0% 00007f19fa34ecec
\end{lstlisting}

\section*{Improvements}

\subsection*{Memoization and SIMD}

\subsection*{Threading}

The second major improvement done was to make the code multithreaded. We accomplished this using pthreads, as shown in the diff given by Listing~\ref{lst:Pthreads}.

\begin{lstlisting}[caption={Pthreads},label={lst:Pthreads}]
diff --git a/model.cpp b/model.cpp
index 23fdea9..26e59e5 100644
--- a/model.cpp
+++ b/model.cpp
@@ -1,5 +1,8 @@
+#include <pthread.h>
 #include "model.h"
 
+#define NUM_THREADS 16
+

 
+struct MemoizedData {
+  int h;
+  double VARA;
+  double VARB;
+  double VARP;
+
+  pair<QPoint, QPoint>* linesData;
+  pair<QPoint, QPoint>* auxData;
+  QImage** imgs;
+  int lines;
+  int himg;
+  int wimg;
+  double *QPs_x;
+  double *QPs_y;
+  double *pQPs_x;
+  double *pQPs_y;
+  QVector2D *Q2P2s;
+  QVector2D *pQ2P2s;
+  double *QPlengths;
+  double *QPlengthsSquared;
+  double *Q2P2lengths;
+  double *powVARP;
+};
+
+struct ThreadData {
+  int i;
+  int iterations;
+  
+  MemoizedData* data;
+};
+
+void* morph_thread(void* arg);
+
 Model::Model() {
   for (unsigned int i = 0; i < NUM_IMAGES; ++i) imgs[i] = new QImage();
 
@@ -116,7 +152,6 @@ void Model::morph(int h, double VARA, double VARB, 
                                      double VARP) {
   double QPs_y[lines];  
   double pQPs_x[lines];
   double pQPs_y[lines];
-
   QVector2D Q2P2s[lines];
   QVector2D pQ2P2s[lines];
   double QPlengths[lines];
@@ -148,8 +183,69 @@ void Model::morph(int h, double VARA, double VARB, 
                                       double VARP) {
     Q2P2lengths[k] = Q2P2s[k].length();
   }
 
-  for(int i=0; i<wimg; ++i) {
-    for(int j=0; j<himg; ++j) {
+
+  MemoizedData data;
+  data.wimg = wimg;
+  data.himg = himg;
+  data.imgs = imgs;
+  data.linesData = linesData;
+  data.auxData = auxData;
+  data.h = h;
+  data.lines = lines;
+  data.VARA = VARA;
+  data.VARB = VARB;
+  data.VARP = VARP;
+  data.QPs_x = QPs_x;
+  data.QPs_y = QPs_y;
+  data.pQPs_x = pQPs_x;
+  data.pQPs_y = pQPs_y;
+  data.Q2P2s = Q2P2s ;
+  data.pQ2P2s = pQ2P2s;
+  data.QPlengths = QPlengths;
+  data.QPlengthsSquared = QPlengthsSquared;
+  data.Q2P2lengths = Q2P2lengths;
+  data.powVARP = powVARP;
+
+  
+  pthread_t threads[NUM_THREADS];
+  ThreadData threadData[NUM_THREADS];
+
+  int offset_stride = himg/NUM_THREADS;
+  int offset = 0;
+  for(int i=0; i <NUM_THREADS; i++) {
+    threadData[i].i = offset;
+    threadData[i].iterations = offset_stride;
+    threadData[i].data = &data;
+    offset += offset_stride;
+
+    if(i == NUM_THREADS -1) {
+      threadData[i].iterations += himg % NUM_THREADS;
+    }
+    
+    pthread_create(&threads[i], NULL,  morph_thread, &threadData[i]);
+  }
+
+  for(int i=0; i <NUM_THREADS; i++) {
+    pthread_join(threads[i], NULL);
+  }
+  
+
+}
+
+void* morph_thread(void* arg) {
+  ThreadData* threadData = (ThreadData*) arg;
+  MemoizedData* d = threadData->data;
+
+  int h = d->h;
+  int lines = d->lines;
+  double VARA = d->VARA;
+  double VARB = d->VARB;
+  QImage** imgs = d->imgs;
+  int wimg = d->wimg;
+  int himg = d->himg;
+
+  for(int j=threadData->i; j< (threadData->i + threadData->iterations); ++j) {
+    for(int i=0; i<wimg; ++i) {
       QPoint X(i, j);
             
       vec4d ww;
@@ -160,28 +256,28 @@ void Model::morph(int h, double VARA, double VARB, 
                                        double VARP) {
       double v[lines];
 
       for(int k = 0; k < lines; ++k) {
-        QPoint P = linesData[k].first;
+        QPoint P = d->linesData[k].first;
         double XPx = X.x() - P.x();
         double XPy = X.y() - P.y();
 
-        u[k] = (XPx * QPs_x[k] + XPy * QPs_y[k]) / QPlengthsSquared[k];
-        v[k] = (XPx * pQPs_x[k] + XPy * pQPs_y[k]) / QPlengths[k];        
+        u[k] = (XPx * d->QPs_x[k] + XPy * d->QPs_y[k]) / d->QPlengthsSquared[k];
+        v[k] = (XPx * d->pQPs_x[k] + XPy * d->pQPs_y[k]) / d->QPlengths[k];        
       }
 
       QVector2D X2s[lines];
       for(int k = 0; k < lines; ++k) {
-        QPoint P2 = auxData[k].first;
-        X2s[k] = QVector2D(P2) + u[k] * Q2P2s[k] + (v[k] * pQ2P2s[k]) / 
-        Q2P2lengths[k];
+        QPoint P2 = d->auxData[k].first;
+        X2s[k] = QVector2D(P2) + u[k] * d->Q2P2s[k] + (v[k] * d->pQ2P2s[k]) 
+       / d->Q2P2lengths[k];
       }
 
       for(int k = 0; k < lines; ++k) {
-        QPoint P = linesData[k].first;
+        QPoint P = d->linesData[k].first;
 
         double dist = 0;
         if(u[k] > 0 && u[k] < 1) {
           dist = fabs(v[k]);
         } else {
-          QPoint Q = linesData[k].second;
+          QPoint Q = d->linesData[k].second;
 
           if(u[k] <= 0) {
             dist = sqrt(pow(X.x() - P.x(), 2.0) + pow(X.y() - P.y(), 2.0));
@@ -191,7 +287,7 @@ void Model::morph(int h, double VARA, double VARB, 
                                      double VARP) {
         }
 
         double w;
-        w =  powVARP[k];
+        w =  d->powVARP[k];
         w /= (VARA + dist);
         w = pow(w, VARB);
 

\end{lstlisting}

The benchmarks are given in the Table~\ref{tbl-pthread-bench}.

\begin{table}[H]
  \centering
  \begin{tabular}{lr}
    & {\bf Time (s)} \\
    \hline
    Run 1 & 9.600 \\
    Run 2 & 9.852 \\
    Run 3 & 9.320 \\
    Run 4 & 9.578 \\
    Run 5 & 9.526 \\
    \hline
    Average & 9.575 \\
  \end{tabular}
  \caption{Benchmark results for pthread optimization}
  \label{tbl-pthread-bench}
\end{table}

The average time is 9.575, which is a X time speed-up over just the previous improvement alone. This version
is faster because we can offload the heavy lifting in the modell::morph method to all eight CPU cores.

This improvement does not change the fundamental operation of the program because it just splits the work
into eight sub-images. These sub-images are indipendent and the resulting composite image is the same
as the one produced by the original code.



\end{document}
